## 网络模型

*将计算机网络划分为不同的层级，每一层都负责特定的功能。每层都构建在下方层级之上，下层为上层提供服务*

#### OSI七层网络模型——自底向上

*开放式系统互联，是国际标准化组织ISO制定的一个用于计算机或通信系统间互联的标准体系*

1. 物理层：规定物理传输媒介，电气信号标准。主要作用是传输比特。（电气信号传播，电电气信号与数字信号的转换，传输的数据叫做比特）
2. 数据链路层：建立物理连接，定义数据在单个链路上如何传输，以以太网为例，以帧的格式进行传输，利用MAC提供身份进行寻址，同时进行差错校验（封装成帧，传输单位是帧）
3. 网络层：建立逻辑连接，提供统一的身份（IP地址），负责数据的路由和转发（路由器）。（常用的协议ICMP，ARP，IP）
4. 传输层：提供端到端的数据传输服务（UDP，TCP）
5. 会话层：应用程序之间的会话连接的管理。
6. 表示层：数据格式转换，加密解密操作。
7. 应用层：负责数据的解析和处理。这一层为用户的应用程序提供了网络服务。（常见协议FTP，SMTP，HTTP，DNS）

*在实际⽹络应用中，常⽤的TCP/IP协议栈更为⼴泛和普遍*

#### TCP/IP四层网络模型

*TCP/IP模型是互联⽹业界最常⽤的协议栈*

1. 网络接口层：对应OSI网络模型的物理层和数据链路层，负责物理传输媒介，建立物理连接，规定了了链路如何传输数据，如以太网、WIFI，提供差错检测，物理身份管理（MAC）
2. 网络层：建立逻辑连接，提供统一身份，负责数据的路由转发
3. 传输层：提供端到端的数据传输服务
4. 应用层：对应OSI模型的会话层，表示层，网络层。负责网络数据的格式转化，数据的解析和处理操作。为用户提供网络服务

*在实际的网络应用中，TCP/IP四层模型更为常用*

#### 五层网络模型

*五层网络模型是结合OSI模型和TCP/IP四层网络模型结合的得出的，便于应用教学*

1. 物理层：负责物理传输媒介得传输
2. 数据链路层：建立主机间得物理连接，定义了数据再单个链路上如何传输，提供了身份识别，地址寻址，差错检测，帧同步。(MAC，帧)
3. 网络层：建立主机间的逻辑连接，提供统一身份识别（IP），进行网络数据包的分组转发
4. 传输层：提供端到端的网络服务，负责两个主机间网络进程的通信
5. 应用层：定义了如何解析和处理数据。为用户提供网络服务。

## 从输入URL到页面展示发生了什么

1. URL输入：在用户输入URL并访问后，浏览器会根据URL提取出URL中的域名
2. 域名解析:  根据从URL解析中得到的域名通过DNS从域名得到请求目标的IP地址
3. 建立连接：浏览器获得目标主机IP地址后与服务器建立TCP连接。（三次握手）
4. HTTP请求：在建立好TCP连接后，浏览器向服务器发送http请求网页内容，请求中包含了请求路径，请求方法，头部信息，请求体
5. HTTP响应：服务端收到客户端发来的http请求后，根据请求内容和路径处理请求并响应。（服务端可能从数据库中获取数据，生成动态内容然后将响应发送给服务端）
6. 接收响应：浏览器收到服务端返回的响应信息，响应中包含了http状态码，头部信息，页面内容等
7. 解析和渲染：浏览器解析响应内容，解析HTML，渲染CSS样式，执行JavaScript

10. 加载资源：页面可能依赖于其它服务端资源，浏览器根据需求下载这些资源以完整地呈现页面
11. 完成页面加载：浏览器页面地所有内容加载完毕后，浏览器显示完整的画面内容

## HTTP

#### HTTP请求报文

1. 请求行：包含了请求方法，请求URL（协议://主机:端口/路径?参数）和使用的HTTP协议版本号
2. 请求头部：KV形式存储的有关请求信息
3. 空行（/r/n）：分割区分请求头部和请求体
4. 请求体：可选内容，承载多个请求参数。在使用POST提交表单或PUT上传文件时，请求主体包含了这些数据

#### HTTP响应报文

1. 状态行：包含使用的HTTP协议，状态码和状态
2. 响应头部：KV形式存储的有关服务端响信息
3. 空行：分割响应头和响应体
4. 相应主体：响应主体包含了服务端返回给客户端的实际数据。如请求一个网页会返回一个HTML内容。

#### HTTP常见字段

##### 通用头部字段

* Cache-Control：指定缓存策略
* Connection：控制连接行为
* Date：指定连接和时间

##### 请求头部字段

* Acceptor：指定客户端能够接受的响应MIME类型
* Acceptor-Encoding：客户端可接受的编码类型
* Authorization：身份验证凭证
* Host：请求目标的主机和端口
* User-Agent：标识客户端的用户代理（浏览器或其它工具）

#### HTTP请求方法

1. GET：向服务器申请资源，不对服务器产生影响
2. POST：通常用于发送数据，如提交表单，上传文件等，会对服务器产生影响，服务器可能动态产生资源或更新已有的资源
3. HEAD：类似GET，只要求服务器返回头部信息
4. PUT：创建或更新服务器上的资源
5. DELETE：请求删除服务器上的资源
6. TRACE：用于测试，要求返回原始的HTTP请求内容
7. PATCH：对服务器资源进行部分更新
8. CONNECT：代理服务器
9. OPTIONS：用于获取服务器所支持的HTTP方法列表，以及对指定资源支持的方法

##### GET和POST的区别

*都是HTTP协议的请求方法*

* GET用于申请服务器资源，不会对服务器产生影响
* POST用于客户端向服务器提交数据，会影响服务器，服务器可能动态创建或者修改原有的内容
* 请求数据：GET为空，POST主要用户表单场景

###### 参数传递

* GET方法参数放在URL中，对于GET传送的数据量较小，不能大于2KB，且只支持ASCII字符
* POST方法请求参数放在请求体中，对请求信息没有长队和数据类型的限制

###### 安全和幂等性

*安全：请求方法不破坏服务器资源*

*幂等：多次相同的请求结果相同*

- GET安全幂等
- POST不安全不幂等

###### 缓存机制

- GET会被浏览器主动缓存，POST不会
- GET请求参数会保存到浏览器历史中，POST不会
- GET产生的URL地址可用被保存为书签，POST不可以
- GET请求在浏览器回退时是无害的，而POST会再次提交请求

###### 耗时

- GET发送一个数据包，header和data一起发送，服务器响应200
- POST发送两个数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200

###### 编码方式

- GET只有URL编码
- POST支持多种编码方式

#### HTTP状态码

| 状态码 | 含义                           |
| ------ | ------------------------------ |
| 1XX    | 协议处理中间状态，需要后续操作 |
| 2XX    | 请求成功                       |
| 3XX    | 求情重定向                     |
| 4XX    | 客户端请求错误                 |
| 5XX    | 服务器错误                     |

##### 1XX

##### 2XX

- 200：请求成功
- 201：请求成功且在服务端创建了新资源
- 202：已接受，未处理
- 203：服务器成功处理，但返回信息来自另一源
- 204：成功处理，无返回信息
- 206：成功处理了部分请求（断点续传、切片下载）

##### 3XX

- 301：网页永久转移到新位置
- 302：请求资源还在，但需暂时访问另一个URL
- 304：自上次请求后，服务器内容未修改，服务器响应时重定向到已存在的缓存文件

##### 4XX

- 401：未授权，需要身份验证
- 403：服务器拒绝请求
- 404：未找到
- 405：请求方法错误
- 429：请求过多

##### 5XX

- 500：服务器内部错误
- 501：服务器没有完成该请求的功能
- 502：服务器作为网关或者代理，从上游服务器收到无效响应
- 503：服务器目前不可用（维护）
- 504：服务器作为网关或者代理，无法及时收到上游服务器的响应

#### HTTP缓存有几种

*HTTP缓存可用减少不必要的网络传输，节省带宽，更快的加载页面，减少服务器负载*

##### 强制缓存

强缓存：浏览器判断请求是否命中强缓存，命中则直接返回缓存资源，无需与服务端通信

`Expires强缓存`：强缓存实践，在实践范围内从内存中读取缓存并返回

`Cache-Control强缓存`：http1.1中增加该字段，使用`max-age`指令，可以设置资源在缓存中存在的最长有效时间，单位秒。

##### 协商缓存

*依赖客户端与服务端的交互。服务端响应客户端中提供了一个标识信息，客户端在后续请求中通过标识判断资源是否发生了变化是否需要重传该资源*

**常见字段**

###### `ETag`和`if-none-match`

- ETag是服务器资源的唯一标识，是根据文件内容计算的哈希值
- 客户端在请求头中if-none-match携带了上次响应的ETag
- 服务端比较请求中的ETag值，如果匹配返回304

###### `Last-Modified`和`if-Modified-Since`

- Last-Modified标识资源的最后修改时间
- 客户端请求时在if-modified-since携带了上次响应的last-modified
- 服务端比较请求中的last-modified是否早于本地资源的最后修改时间，如果资源自请求时间后为修改，则返回304

#### HTTP版本

##### HTTP1.0和HTTP1.1的区别

1. 长连接
   - http1.1支持长连接，一条TCP连接上可以处理多个HTTP请求和响应，默认开启`Connection: Keep-alive`
   - http1.0默认为短连接，每次请求都需要建立一个TCP连接

2. 缓存
   - http1.0主要使用`if-modified-since/Expires`作为缓存判断标准
   - http1.1引入了更多缓存策略，如`ETag/if-none-match`等来控制缓存策略

3. 管道化
   - 基于http1.1的长连接可以使用管道化技术，管道化可以使得请求能够“并行”传输，但是响应必须按照请求顺序依次返回，一定程度上改善了性能

4. Host字段
   - 一个服务器可以创建多个web站点

5. 状态码
   - 新增24个错误状态码

6. 带宽优化
   - http1.0不能请求部分对象，不支持断点续传
   - http1.1引入了`range`字段，运行请求部分资源，优化了带宽

##### HTTP1.1有什么特性

1. 持久化连接
2. 管道化
3. 增加了PUT，DELETE，OPTIONS，PATCH请求新方法
4. 增加了错误码
5. 增加缓存字段，提供了更多的缓存策略
6. 引入`range`头域，支持资源的部分请求，允许响应数据分块，利于大文件传输
7. 增加`host`字段，支持一个服务器部署多个web站点

##### HTTP2.0和HTTP1.1有什么区别

1. 传输格式变化，采用二进制格式
   - htpp1.x的解析都是基于文本的，文本表现多样，不利于健壮性考虑
   - http2.0采用二进制，实现更快的方法，健壮性更加完善
2. 多路复用
   - 一个请求对应一个id，每个连接都可以有多个请求，接收发可以根据请求的id将请求再归属到各自不同的服务端请求中，提高效率
3. header压缩
   - 在http1.x中header带有大量信息，而且每次都要重复发送
   - http2.0通过encoder减少了header大小，通讯双方会各自缓存一份header字段表
   - 避免了重复传又减少了传输大小
4. 服务端推送
   - 把客户端所需要的资源伴随页面一起发送给客户端，省去了客户端重复请求的步骤，调高了页面响应的速度

##### HTTP3.0和HTTP2.0有什么区别

#### HTTP3

##### HTTPS和HTTP的区别

- HTTP超文本传输协议，明文传输，存在安全问题。HTTPS提出是为了解决HTTP明文传输的不安全问题，在HTTP和TCP之间增加了SSL/TLS安全协议，使得报文可以密文传输
- HTTP值进行三次握手，HTTPS在三次握手之后会进行SSL/TLS的四次握手
- HTTP/80，HTTPS/443
- HTTPS协议需要向CA申请数字证书来保证服务器的身份（公钥）是可信的

##### SSL/TLS是什么

- SSL安全套接字
- TLS安全传输层协议
- HTTPS是基于SSL/TLS的安全版本HTTP协议

**SSL/TLS实现安全通信的方式（CIA）**

- 加密：加密算法
- 身份验证：数字证书
- 数据完整新：消息摘要（保温鉴别码）

##### 对称加密和非对称加密

- 对称加密：使用一对相同的密钥进行加密解密，速度快
- 非对称加密：使用一对相关的公钥和私钥进行加密解密，公钥加密的数据可以使用私钥解密，私钥加密的数据可以使用公钥解密。公钥可靠新——CA，私钥还可用于数字签名。

##### HTTPS建立连接的过程

1. 客户端发送请求：当客户端想要使用HTTPS进行通信时，它会发送一个连接请求到服务器的443端口
2. 服务器响应：服务器收到响应之后会发送一个CA数字证书给客户端，这个证书包含了服务器的公钥和颁发证书的认证机构的信息
3. 客户端验证证书：客户端接收到服务器发送的数字证书后，验证数字证书合法性。包括验证证书的签名，证书是否过期和是否与预期域名向匹配
4. 生成会话密钥：证书验证成功，客户端生成一个用于该链接通话的会话密钥（对称密钥），这个密钥将用于加密通信数据
5. 使用公钥加密会话密钥：客户端使用公钥对会话密钥进行加密然后发送给服务器
6. 服务器解密会话密钥：服务端收到加密的会话密钥后利于自己的私钥解密获得会话密钥
7. 建立安全通信：至此，服务端和客户端都有了会话密钥，它们使用对称加密算法和会话密钥进行加密通信，保证了数据传输的隐私和完整性

## URL和URI是什么

- URI：统一资源标识符，用于标识互联网上的任何资源
- URL：统一资源定位符，URL是URI的特殊形式，不仅标识资源，还提供资源的位置信息，即如何定位和获取资源
- URL的组成：`协议://IP:Port/Path?Param=value#section（片段标识）`

## DNS

#### DNS是什么

​	**`DNS`是域名系统，提供的服务是将域名转化为对应的IP地址**

#### DNS解析过程

1. 查询浏览器缓存是否有该域名对应的ip地址
2. 如果缓存中没有则回去计算机本地的Host文件中查询是否有对应的缓存
3. 如果Host中没有则放本地DNS服务器发送一个DNS请求（ISP提供）
4. 如果DNS服务器有该域名对应的IP地址，则会直接返回， 否则向根DNS服务器发送查询请求。根DNS服务器告诉本地DNS服务器顶级域名服务器地址
5. 本地DNS服务器向顶级域名服务器发送DNS请求，顶级域名服务器告诉本地域名服务器对应的权威域名服务器地址
6. 本地DNS服务器再请求权威DNS服务器发送查询请求。权威域名服务器负责存储特定的域名和IP映射，权威域名服务器会查找域名对应的IP后返回给本地DNS服务器
7. 本地DNS服务器收到IP地址后返回给浏览器并将结果缓存到本地

#### 递归查询和迭代查询

*递归查询适合普通用户和客户端，迭代查询适合DNS服务器之间的通讯*

- 递归查询：需要请求一个完整结果
- 迭代查询：无需完整结果，直到请求到结果为止

## TCP/UDP

